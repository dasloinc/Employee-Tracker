"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cellText = exports.createHeaderAsRow = exports.printTableHorizontalBorders = exports.printTableTitleInConsole = exports.findMaxLenOfColumn = exports.createRow = exports.createColum = exports.createTableHorizontalBorders = exports.textWithPadding = exports.preProcessRows = exports.convertRawRowOptionsToStanrd = void 0;
const table_constants_1 = require("./table-constants");
function convertRawRowOptionsToStanrd(options) {
    if (options) {
        return {
            color: table_constants_1.COLOR[options.color],
        };
    }
    return undefined;
}
exports.convertRawRowOptionsToStanrd = convertRawRowOptionsToStanrd;
function preProcessRows(rows, filterFunc, sortFunc) {
    return rows
        .filter((r) => filterFunc(r.text))
        .sort((r1, r2) => sortFunc(r1.text, r2.text));
}
exports.preProcessRows = preProcessRows;
function textWithPadding(text, alignment, mxColumnLen) {
    const curTextSize = text.length;
    switch (alignment) {
        case table_constants_1.ALIGNMENT.left:
            return text.padEnd(mxColumnLen);
        case table_constants_1.ALIGNMENT.right:
            return text.padStart(mxColumnLen);
        case table_constants_1.ALIGNMENT.center:
            return text
                .padStart((mxColumnLen - curTextSize) / 2 + curTextSize)
                .padEnd(mxColumnLen);
        default:
            return text.padStart(mxColumnLen);
    }
}
exports.textWithPadding = textWithPadding;
function createTableHorizontalBorders({ left, mid, right, other, }, column_lengths) {
    let ret = left;
    column_lengths.forEach((len) => {
        ret += other.repeat(len + 2);
        ret += mid;
    });
    ret = ret.slice(0, -1);
    ret += right;
    return ret;
}
exports.createTableHorizontalBorders = createTableHorizontalBorders;
function createColum(name) {
    return { name };
}
exports.createColum = createColum;
function createRow(color, text) {
    return { color, text };
}
exports.createRow = createRow;
function findMaxLenOfColumn(column, rows) {
    const column_name = column.name;
    let max_ln = `${column_name}`.length;
    rows.forEach((row) => {
        max_ln = Math.max(max_ln, `${row.text[column_name] || ''}`.length);
    });
    return max_ln;
}
exports.findMaxLenOfColumn = findMaxLenOfColumn;
function printTableTitleInConsole(title) {
    console.log(title);
    return title;
}
exports.printTableTitleInConsole = printTableTitleInConsole;
function printTableHorizontalBorders(style, column_lengths) {
    const str = createTableHorizontalBorders(style, column_lengths);
    console.log(str);
    return str;
}
exports.printTableHorizontalBorders = printTableHorizontalBorders;
function createHeaderAsRow(createRowFn, columns) {
    const row = createRowFn(table_constants_1.COLOR.white_bold, {});
    columns.forEach((column) => {
        row.text[column.name] = column.name;
    });
    return row;
}
exports.createHeaderAsRow = createHeaderAsRow;
function cellText(text) {
    return text === undefined || text === null ? '' : text;
}
exports.cellText = cellText;
